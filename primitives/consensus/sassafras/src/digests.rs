// Copyright 2019 Parity Technologies (UK) Ltd.
// This file is part of Substrate.

// Substrate is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Substrate is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Substrate.  If not, see <http://www.gnu.org/licenses/>.

use codec::{Encode, Decode};
use sp_std::vec::Vec;
use sp_core::RuntimeDebug;
use sp_consensus_vrf::schnorrkel;
use crate::{
	Randomness, VRFIndex,
	AuthorityIndex, SlotNumber, AuthorityId, SassafrasAuthorityWeight,
};

#[cfg(feature = "std")]
use codec::Codec;
#[cfg(feature = "std")]
use sp_runtime::{DigestItem, generic::OpaqueDigestItemId};
#[cfg(feature = "std")]
use crate::{SASSAFRAS_ENGINE_ID, AuthoritySignature};

/// Raw Sassafras primary slot assignment pre-digest.
#[derive(Clone, RuntimeDebug, Encode, Decode)]
pub struct RawPrimaryPreDigest<VRFOutput=schnorrkel::RawVRFOutput, VRFProof=schnorrkel::RawVRFProof> {
	/// Index of ticket VRF proof that has been previously committed.
	pub ticket_vrf_index: VRFIndex,
	/// Attempt number of the ticket VRF proof.
	pub ticket_vrf_attempt: u64,
	/// Reveal of tocket VRF output.
	pub ticket_vrf_output: VRFOutput,
	/// Validator index.
	pub authority_index: AuthorityIndex,
	/// Corresponding slot number.
	pub slot_number: SlotNumber,
	/// Secondary "Post Block VRF" proof.
	pub post_vrf_proof: VRFProof,
	/// Secondary "Post Block VRF" output.
	pub post_vrf_output: VRFOutput,
	/// Additional commitments posted directly at pre-digest.
	pub commitments: Vec<VRFProof>,
}

#[cfg(feature = "std")]
/// Sassafras primary slot assignment pre-digest for std environment.
pub type PrimaryPreDigest = RawPrimaryPreDigest<schnorrkel::VRFOutput, schnorrkel::VRFProof>;

/// A secondary Sassafras pre-digest.
#[derive(Clone, RuntimeDebug, Encode, Decode)]
pub struct RawSecondaryPreDigest<VRFProof=schnorrkel::RawVRFProof> {
	/// Authority index.
	pub authority_index: AuthorityIndex,
	/// Slot number.
	pub slot_number: SlotNumber,
	/// Additional commitments posted directly at pre-digest.
	pub commitments: Vec<VRFProof>,
}

/// A Sassafras pre-digest. The validator pre-commit a VRF proof at `vrf_index`, and now reveal it
/// as `vrf_output`.
///
/// This digest is included in every block, generated by Sassafras consensus engine.
#[derive(Clone, RuntimeDebug, Encode, Decode)]
pub enum RawPreDigest<VRFOutput=schnorrkel::RawVRFOutput, VRFProof=schnorrkel::RawVRFProof> {
	/// A primary VRF-based slot-assignment.
	Primary(RawPrimaryPreDigest<VRFOutput, VRFProof>),
	/// A secondary deterministic slot assignment.
	Secondary(RawSecondaryPreDigest<VRFProof>),
}

#[cfg(feature = "std")]
/// A Sassafras pre-runtime digest for std.
pub type PreDigest = RawPreDigest<schnorrkel::VRFOutput, schnorrkel::VRFProof>;

impl PreDigest {
	/// Returns the slot number of the pre digest.
	pub fn authority_index(&self) -> AuthorityIndex {
		match self {
			PreDigest::Primary(p) => p.authority_index,
			PreDigest::Secondary(s) => s.authority_index,
		}
	}

	/// Returns the slot number of the pre digest.
	pub fn slot_number(&self) -> SlotNumber {
		match self {
			PreDigest::Primary(p) => p.slot_number,
			PreDigest::Secondary(s) => s.slot_number,
		}
	}

	/// Returns the weight _added_ by this digest, not the cumulative weight
	/// of the chain.
	pub fn added_weight(&self) -> super::SassafrasBlockWeight {
		match self {
			PreDigest::Primary(_) => 1,
			PreDigest::Secondary(_) => 0,
		}
	}
}

/// Post-digest about next epoch information.
///
/// This digest is generated by runtime, at the beginning of every epoch.
#[derive(Clone, RuntimeDebug, Encode, Decode)]
pub struct NextEpochDescriptor {
	/// The authorities that generate VRF proofs. Note that those keys will only be generating
	/// blocks two epochs later.
	pub authorities: Vec<(AuthorityId, SassafrasAuthorityWeight)>,
	/// Value of randomness to use for slot-assignment. This is expected to use the secondary "Post
	/// VRF".
	pub randomness: Randomness,
}

/// Post-digest about post-block information such as ticket commitments.
///
/// This digest is generated by runtime, optional, and can be included at every block.
#[derive(Clone, RuntimeDebug, Encode, Decode)]
pub struct RawPostBlockDescriptor<VRFProof=schnorrkel::RawVRFProof> {
	/// Commitments of tickets.
	pub commitments: Vec<VRFProof>,
}

#[cfg(feature = "std")]
/// Sassafras post-digest suitable for std environment.
pub type PostBlockDescriptor = RawPostBlockDescriptor<schnorrkel::VRFProof>;

/// A digest item which is usable with Sassafras consensus.
#[cfg(feature = "std")]
pub trait CompatibleDigestItem: Sized {
	/// Construct a digest item which contains a Sassafras `PreDigest`.
	fn sassafras_pre_digest(seal: PreDigest) -> Self;

	/// Construct a digest item which contains a Sassafras seal.
	fn sassafras_seal(signature: AuthoritySignature) -> Self;

	/// If this item is a Sassafras `PreDigest`, return it.
	fn as_sassafras_pre_digest(&self) -> Option<PreDigest>;

	/// If this item is a Sassafras `NextEpochDescriptor`, return it.
	fn as_sassafras_next_epoch_descriptor(&self) -> Option<NextEpochDescriptor>;

	/// If this item is a Sassafras `PostBlockDescriptor`, return it.
	fn as_sassafras_post_block_descriptor(&self) -> Option<PostBlockDescriptor>;

	/// If this item is a Sassafras seal, return it.
	fn as_sassafras_seal(&self) -> Option<AuthoritySignature>;
}

#[cfg(feature = "std")]
impl<Hash> CompatibleDigestItem for DigestItem<Hash> where
	Hash: core::fmt::Debug + Send + Sync + Eq + Clone + Codec + 'static
{
	fn sassafras_pre_digest(seal: PreDigest) -> Self {
		DigestItem::PreRuntime(SASSAFRAS_ENGINE_ID, seal.encode())
	}

	fn sassafras_seal(signature: AuthoritySignature) -> Self {
		DigestItem::Seal(SASSAFRAS_ENGINE_ID, signature.encode())
	}

	fn as_sassafras_pre_digest(&self) -> Option<PreDigest> {
		self.try_to(OpaqueDigestItemId::PreRuntime(&SASSAFRAS_ENGINE_ID))
	}

	fn as_sassafras_next_epoch_descriptor(&self) -> Option<NextEpochDescriptor> {
		self.try_to(OpaqueDigestItemId::Consensus(&SASSAFRAS_ENGINE_ID))
			.and_then(|x: super::ConsensusLog| match x {
				super::ConsensusLog::NextEpochData(n) => Some(n),
				_ => None,
			})
	}

	fn as_sassafras_post_block_descriptor(&self) -> Option<PostBlockDescriptor> {
		self.try_to(OpaqueDigestItemId::Consensus(&SASSAFRAS_ENGINE_ID))
			.and_then(|x: super::ConsensusLog| match x {
				super::ConsensusLog::PostBlockData(p) => Some(p),
				_ => None,
			})
	}

	fn as_sassafras_seal(&self) -> Option<AuthoritySignature> {
		self.try_to(OpaqueDigestItemId::Seal(&SASSAFRAS_ENGINE_ID))
	}
}
