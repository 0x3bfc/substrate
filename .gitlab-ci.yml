# .gitlab-ci.yml
#
# substrate
#
# pipelines can be triggered manually in the web
# setting DEPLOY_TAG will only deploy the tagged image

# SAMPLE JOB TEMPLATE - This is not a complete example but is enough to build a
# simple CI job. For full documentation, visit https://docs.gitlab.com/ee/ci/yaml/
#
# my-example-job:
#   stage:                           test # One of the stages listed below this job (required)
#   image:                           paritytech/tools:latest # Any docker image (required)
#   allow_failure:                   true # Allow the pipeline to continue if this job fails (default: false)
#   dependencies:
#     - build-rust-doc-release # Any jobs that are required to run before this job (optional)
#   variables:
#     MY_ENVIRONMENT_VARIABLE:       "some useful value" # Environment variables passed to the job (optional)
#   script:
#     - echo "List of shell commands to run in your job"
#     - echo "You can also just specify a script here, like so:"
#     - ./.maintain/gitlab/my_amazing_script.sh

stages:
  - check
  - test
  - build
  - post-build-test
  - publish
  - deploy
  - flaming-fir

variables:                         &default-vars
  GIT_STRATEGY:                    fetch
  GIT_DEPTH:                       100
  CARGO_INCREMENTAL:               0
  DOCKER_OS:                       "debian:stretch"
  ARCH:                            "x86_64"
  # FIXME set to release
  CARGO_UNLEASH_INSTALL_PARAMS:    "--version 1.0.0-alpha.10"
  CARGO_UNLEASH_PKG_DEF:           "--skip node node-* pallet-template pallet-example pallet-example-* subkey chain-spec-builder"

default:
  cache:                           {}

.collect-artifacts:                &collect-artifacts
  artifacts:
    name:                          "${CI_JOB_NAME}_${CI_COMMIT_REF_NAME}"
    when:                          on_success
    expire_in:                     7 days
    paths:
      - artifacts/

.kubernetes-build:                 &kubernetes-build
  tags:
    - kubernetes-parity-build
  environment:
    name: parity-build
  interruptible:                   true

.docker-env:                       &docker-env
  image:                           paritytech/ci-linux:production
  before_script:
    - rustup show
    - cargo --version
    - sccache -s
  only:
    - master
    - /^v[0-9]+\.[0-9]+.*$/        # i.e. v1.0, v2.1rc1
    - schedules
    - web
    - /^[0-9]+$/                   # PRs
  retry:
    max: 2
    when:
      - runner_system_failure
      - unknown_failure
      - api_failure
  interruptible:                   true
  tags:
    - linux-docker

.build-only:                       &build-only
  only:
    - master
    - /^v[0-9]+\.[0-9]+.*$/        # i.e. v1.0, v2.1rc1
    - /^pre-v[0-9]+\.[0-9]+-[0-9a-f]+$/
    - web

#### stage:                       .pre

skip-if-draft:
  image:                           paritytech/tools:latest
  <<:                              *kubernetes-build
  stage:                          .pre
  only:
    - /^[0-9]+$/                  # Pull requests
  script:
     - ./.maintain/gitlab/skip_if_draft.sh

#### stage:                        check

codecov:
  stage:                           test
  <<:                              *docker-env
  variables:
    # Variables partly came from https://github.com/mozilla/grcov/blob/master/README.md
    # CARGO_INCREMENTAL: 0 is important, but mentioned in defaults.
    RUSTFLAGS:                     "-Zprofile -Zmir-opt-level=0 -Ccodegen-units=1
                                      -Copt-level=0 -Clink-dead-code -Coverflow-checks=off"
    # The `cargo-taurpalin` coverage reporting tool seems to have better code instrumentation and thus
    # produces better results for Rust codebases in general. However, unlike `grcov` it requires
    # running docker with `--security-opt seccomp=unconfined` which is why we use `grcov` instead.
    # We removed the `-Cinline-threshold=0` flag from the above `RUSTFLAGS` since it was bugged
    # at the time and lead to inlining of functions that shouldn't be inlined for the coverage
    # report. (More information here: https://github.com/Kogia-sima/rust-covfix/issues/2)
    WASM_BUILD_NO_COLOR:           1
  script:
    # RUSTFLAGS are the cause target cache can't be used here
    - unset "CARGO_TARGET_DIR"
    - cargo clean
    - time cargo +nightly install grcov rust-covfix
    - time cargo +nightly test --workspace --locked --release --verbose -Z package-features --features runtime-benchmarks --no-fail-fast
    # - cargo build might also be needed
    # coverage with branches
    - grcov ./target -s . -t lcov --llvm --branch --ignore-not-existing --ignore "/*" --ignore "tests/*" -o lcov-w-branch.info
    - rust-covfix -o lcov-w-branch.info lcov-w-branch.info
    - bash <(curl -s https://codecov.io/bash) -t "$CODECOV_P_TOKEN" -f lcov-w-branch.info
    # lines coverage
    # - grcov ./target -s . -t lcov --llvm --ignore-not-existing --ignore "/*" --ignore "tests/*" -o lcov-lines.info
    # - rust-covfix -o lcov-lines.info lcov-lines.info
    # - bash <(curl -s https://codecov.io/bash) -f lcov-lines.info
